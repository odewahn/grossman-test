<section class="pagenumrestart" data-type="chapter" id="introduction_to_computer_science" xmlns="http://www.w3.org/1999/xhtml">
<h1>Introduction to Computer Science</h1>

<aside data-type="sidebar">
<h5>In This Chapter</h5>

<ul>
	<li>
	<p>Defining computer science</p>
	</li>
	<li>
	<p>Programming techniques</p>
	</li>
	<li>
	<p>Algorithms and algorithm efficiency</p>
	</li>
</ul>
</aside>

<section data-type="sect1" id="onedot1_what_is_computer_sciencequestion">
<h1>1.1 Introduction</h1>

<p>Computers work because they run computer programs. &nbsp;Computer programs are sets of instructions that are given to the computer. &nbsp;They are fairly precise. &nbsp;If you mis-spell a word the computer won't understand what you meant. &nbsp;If you add an extra comma somewhere its not like your English teacher will just circle it and move on. &nbsp;Your program won't work.</p>

<p>Hence, new people to computer programming often struggle just to get the basics working. &nbsp;They usually have to set up a whole programming environment which is often a barrier to learning. &nbsp;With this course, you just click on things and enter some answers and POOF you are writing a computer program.&nbsp;</p>

<p>It turns out there is a whole SCIENCE to studying how to really make a computer solve problems. &nbsp;That is called Computer SCIENCE and not Computer Programming. &nbsp;Why? &nbsp;While, it turns out you can study and compare different ways of getting the computer to do something and you can mathematically figure out the best way to do things. &nbsp;So if &nbsp;all you do is get computer programs to work you may miss out on some good lessons learned from people who have studied this for the past fifty years. &nbsp; Think about planting crops. &nbsp;You can do it with a shovel or you can use a tractor. &nbsp;If you are in a world where you haven't even heard of a tractor and all you have is a shovel you might resign yourself to digging the dirt shovel by shovel. &nbsp;One day you'll learn about the tractor and say WOW -- sure wish I had known about that tractor before I spend 30 days in the heat shoveling this field! &nbsp;</p>

<p>So once you get the basics of Computer programming its awfully good to start to learn about computer science and learn what tractors have been developed that will make your life significantly easier. &nbsp;Computer Science also provides ways to solve problems so when faced with a new problem, you will not just throw up your hands, you will have a methodical approach to solving it. &nbsp; So we want you to learn not just computer programming but we want you to learn a little Computer Science as well. &nbsp;</p>

<p>Computer Science is all about concepts and approaches needed to solve problems using a computer. &nbsp;Computer Programming is just about writing a program in a particular programming language. &nbsp;People who just get a program to work in a given language are often fine, but well then, due to various reasons different programming languages become popular. &nbsp;Primarily because Computer Scientists are always trying to come up with new programming languages that will make life easier for programmers. &nbsp;So lets say you decide Ruby (the language we have picked for this course because its so super easy to get started) and then ten years from now some other language comes along that you've never heard of. &nbsp;IF you have the basics of Computer Science in your head, well then you know that the language is just a tool (e.g.; like a shovel, like a tractor) and you adapt quickly because you will know the common things the tool should be able to do and how it will probably work. &nbsp;If you have ignored Computer Science you will thing OH GOODNESS -- how I am to start ALL OVER and LEARN a WHOLE NEW LANGUAGE. &nbsp;</p>

<p>so that's why we harp on teaching some Computer Science along the way with teaching Ruby.&nbsp;</p>

<p>We've decided to try something new with this course. &nbsp; A typical course would teach you all the different commands you might use when programming in Ruby. &nbsp;Then it would start to put them together. &nbsp;We've decided that's too boring and its not so great because if we give you a list of ten commands and you don't use them right away - well you'll probably forget at least a couple of them along the way. &nbsp;Then when we want to use them you'll be lost. &nbsp;So it is for most students taking a course that covers a programming language -- we know as we have taught for over 25 years.&nbsp;</p>

<p>So lets try something new. &nbsp;Lets pretend we are the master and you are the apprentice and lets say we are building a house. &nbsp; If we need you to hammer a nail we say HEY APPRENTICE, come HAMMER THIS NAIL NOW! &nbsp; You have never hammered one. &nbsp;You look blankly at us. &nbsp;We shrug and moan about the troubles with new apprentices. &nbsp;We then pick up a hammer and hammer a nail. &nbsp;We look at you and say GOT IT? &nbsp;You nod and then pick up the hammer the wrong way. &nbsp;We sigh and moan and say NOT THAT WAY, THIS WAY. &nbsp;Then you pick it up correctly. &nbsp;We grumble GOOD. &nbsp;You then hammer the nail sideways so its not straight. &nbsp;We SIGH and MOAN. &nbsp;We say NOT LIKE THAT -- EINSTEIN -- STRAIGHT. &nbsp;I have no idea why I hired you as an apprentice. &nbsp;Then we take the nail out and give you new one and say TRY AGAIN. &nbsp;You do it right. &nbsp;We say GOOD. &nbsp;Now do FIFTY MORE JUST LIKE IT. &nbsp;And so you learn. &nbsp;And you probably don't forget.&nbsp;</p>

<p>With a book we can't really have that interaction.&nbsp;</p>

<p>With an electronic course we think we can and we are eager to try. &nbsp;We think a lot of people could learn programming if they were taught this way and we think a typical book sort of bores a lot of people or confuses them and they just give up or decide not to try. &nbsp;So give it a try and send us feedback so we can refine the course -- but over time we think it'll be a success.&nbsp;</p>

<p>Ready for your first nail to hammer? &nbsp;Good because that is what we are going to do. &nbsp;We are going to do one problem in this e-course and only one and we are going to work with you to make it so you absolutely know how to do it. &nbsp;We have picked the game of blackjack for this course as its one of the first programs that one of the authors was asked to write when he took an intro to computer science course and he loved it and it made it so all he wanted to do was study computer science. &nbsp;So if it worked for him -- well then maybe it'll work for you. &nbsp;</p>

<p>So first you have to know how to play black jack. &nbsp;Its a card game. &nbsp;There are 52 cards in a deck and they have numbers &nbsp;on them. &nbsp;If you have never seen a deck of cards then follow this link &nbsp;to read about decks of cards. &nbsp;Anyway its played between one player and &nbsp;a dealer. &nbsp;There are different versions but we are going to make this one simple.&nbsp;</p>

<p>The dealer deals two cards to a player and one card to the dealer. &nbsp;The dealer shows the player his/her card (for the rest of this course we are calling the dealer a HE but we don't care what gender the dealer is). &nbsp;</p>

<p>&nbsp;</p>

<p>So you are taking this course because maybe you want to learn how to program a computerIntroductory students often confuse programming with computer science, but programming is merely a strategy to implement computer science concepts. We introduce the basics of computer science using the Ruby programming language. Given our goal, we intentionally forgo many of the intricacies of the language.</p>

<p>Computer science is never tied to a programming language; it is tied to the task of solving problems efficiently using a computer. A computer comes with some resources, which will be discussed in , such as internal memory for short-term storage, processing capability, and long-term storage devices. A <em>complete program</em> is a set of instructions that use the computer to solve a real problem. The tool for producing these instructions is called a <em>programming language</em>. The goal is to develop solutions that use these resources efficiently to solve real problems.</p>

<p>Programming languages come and go, but the essence of computer science stays the same. If we need to sort a sequence of numbers, for example, it is immaterial if we sort them using programming language A or B. The steps the program will follow, commonly referred to as the <em>algorithm</em>, will remain the same. Hence, the core goal of computer science is to study algorithms that solve real problems. Computer scientists strive to create a correct sequence of steps that minimize resource demands, operate in a timely fashion, and yield correct results.</p>

<p>Algorithms are typically specified using pseudocode. Pseudocode, which may itself be simply written in plain language, specifies the logical, conceptual steps that must occur without specifying the necessary details needed to actually execute each step. However, we think that a properly selected subset of Ruby is sufficiently simple to introduce the algorithms. So, instead of creating an algorithm by writing it in plain language, generating equivalent pseudocode, and transforming it into a programming language, we go straight from the plain-language definition of an algorithm to Ruby code.</p>
</section>

<section data-type="sect1" id="onedot2_application_development">
<h1>1.2 Application Development</h1>

<p>When writing a program, it is important to keep in mind that the computer will do exactly what you tell it to do. It cannot think as a human would, so you must provide clear instructions for every step.</p>

<p>When giving instructions to others, people will often fill in blanks in logic without even realizing it. For example, if you instruct someone to &acirc;go to the bank,&acirc; you may not say what mode of transportation should be used. A computer, however, does not have the ability to &acirc;fill in the blanks.&acirc; A computer will only do exactly what you tell it to do.</p>

<p>Imagine, for example, explaining to a person and to a computer how to make a peanut butter and jelly sandwich. To the person, all you might need to say is, &acirc;Spread the peanut butter on one slice of bread, the jelly on the other slice of bread, and then put the pieces of bread together.&acirc; If these instructions were given to a computer, however, the computer would not know where to start. Implied in these instructions are many logical steps that a human can automatically infer and the computer cannot. For example, the human would know that the jar must first be opened to scoop peanut butter out before you can spread it onto a slice of bread. The computer might try to spread the actual jar across the bread, without taking the peanut butter or jelly out&acirc;assuming it could even find them!</p>

<p>Computer science is ultimately about problem solving. The following is a basic approach to solving problems:</p>

<ul class="simplelist">
	<li>Step 1: Understand the problem.</li>
	<li>Step 2: Write out a solution in plain language.</li>
	<li>Step 3: Translate the language into code.</li>
	<li>Step 4: Test the code in the computer.</li>
</ul>

<section data-type="sect2" id="step_1_understanding_the_problem">
<h2>Step 1: Understand the Problem</h2>

<p>During this step, you try to answer all questions about the problem at hand. For example, you may be asked to create a program that stores a list of names, like a directory. Instead of just creating this program with little forethought, it is important to know all the details of the problem. Here are some examples:</p>

<ul>
	<li>
	<p>How many names will be stored?</p>
	</li>
	<li>
	<p>Do first and last names need to be stored separately?</p>
	</li>
	<li>
	<p>Are middle names needed?</p>
	</li>
	<li>
	<p>What is the maximum length that a name can be?</p>
	</li>
</ul>
</section>

<section data-type="sect2" id="step_2_write_out_the_solution_in_plain_l">
<h2>Step 2: Write Out the Solution in Plain Language</h2>

<p>Once the problem is understood, the next step is to write an outline of how you will solve it. An example of the process of storing a name might look like a sequence of sentences:</p>

<table>
	<tbody>
		<tr>
			<td>
			<p>Ask for the first name.</p>
			</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>
			<p>Store the first name.</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Ask for the last name.</p>
			</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>
			<p>Store the last name.</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Optionally, ask for the middle initial.</p>
			</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>
			<p>Store the middle initial.</p>
			</td>
		</tr>
	</tbody>
</table>
</section>

<section data-type="sect2" id="step_3_translate_the_language_into_code">
<h2>Step 3: Translate the Language into Code</h2>

<p>Once the plain-language version is written, it is time to translate it into actual code. The Ruby code for the preceding example is shown in , but you are certainly not expected to understand it yet.</p>

<p>Note the pound sign (#) on the righthand side. This sign means that the remainder of the line is a <em>comment</em>. A comment is not part of the instructions given to the computer. That is, a comment is a nonexecutable segment of code. Typically, comments are used to explain what the code does. Not only is it critical to comment code for the sake of readability and understanding, but using comments is considered good programming style, and the liberal use of comments is essential. Always remember that you (or someone else) may have to fix errors&acirc;colloquially referred to as bugs&acirc;years after you write a program; comments will help you understand what your code does years after you initially wrote it.</p>

<div data-type="example" id="english_rarr_ruby_code">
<h5>Plain language &acirc; Ruby code</h5>

<pre data-code-language="ruby" data-type="programlisting">
        1 puts &quot;Enter first name: &quot;	# Ask for the first name
        2 first_name = gets		# Store the first name
        3 puts &quot;Enter last name: &quot;	# Ask for the last name
        4 last_name = gets		# Store the last name
        5 puts &quot;Enter middle initial: &quot;	# Ask for the middle initial
        6 middle_initial = gets		# Store the middle initial
</pre>
</div>
</section>

<section data-type="sect2" id="step_4_test_the_code_in_the_computer">
<h2>Step 4: Test the Code in the Computer</h2>

<p>This step entails running the program you created and seeing that it runs properly. It is best to test portions of your code as you write them, instead of writing an entire program only to find out that none of it works.</p>
</section>
</section>

<section data-type="sect1" id="onedot3_algorithms">
<h1>1.3 Algorithms</h1>

<p>Algorithms are step-by-step methods of solving problems. The process of reading in names previously described is an example of an algorithm, though a very simple one. Some are extremely complicated, and many vary their execution depending on input. Often algorithms take input and generate output, but not always. However, all algorithms have something in common: they all do something.</p>

<div data-type="note" id="ch01note01">
<h1>Gem of Wisdom</h1>

<p>Algorithms are the core of computer science. Correct and efficient algorithms guarantee that the computer works smart rather than only hard. Thus, think about the problem, come up with a good algorithm, and then determine how many steps the computer needs to complete the task.</p>
</div>

<p>Imagine a website like Google Maps, which has an algorithm to get directions from one point to another in either North America or Europe. It typically requires two inputs: a source and a destination. It also gives two outputs: the narrative directions to get from the source to the destination, and a map of the route.</p>

<p>The directions produced are also an algorithm; they accomplish the task of getting from the source to the destination. Imagine getting the directions to your friend&acirc;s house shown on the map in .</p>

<ol>
	<li>
	<p>Start going south on River Road.</p>
	</li>
	<li>
	<p>Turn left (east) on Main Street.</p>
	</li>
	<li>
	<p>Take a right (south) on Ruby Lane.</p>
	</li>
	<li>
	<p>Turn left (east) toward Algorithm Circle.</p>
	</li>
	<li>
	<p>Continue until you come to 345 Algorithm Circle (your friend&acirc;s house).</p>
	</li>
</ol>

<figure id="directions_quotation_markalgorithmquotat" style="float: 0"><img src="images/cspr_0102.png" />
<figcaption>Directions &acirc;algorithm&acirc;</figcaption>
</figure>

<p>First notice that the directions are numbered; each step happens in sequential order. Additionally, it describes general steps like, &acirc;Turn left (east) on Main Street.&acirc; It does not say, &acirc;Turn on your left turn signal and wait for the light to turn green, and then turn left on Main Street.&acirc; That is not the point of an algorithm. An algorithm does not need to write out every single detail, but it needs to have all the important parts.</p>

<section data-type="sect2" id="onedot3dot1_algorithm_efficiency">
<h2>1.3.1 Algorithm Efficiency</h2>

<p>Different algorithms may accomplish the same task, but some will do it much faster than others. Consider the algorithm just described for going to your friend&acirc;s house, which certainly is not the only route to her or his home. Instead of getting on Ruby Lane, you could have hopped on the expressway, gone to the airport, and then taken a cab from the airport to your friend&acirc;s house&acirc;but that would be extremely inefficient. Likewise, there may be a more efficient route to your friend&acirc;s house than the one described. Just because you have created an algorithm does not make it efficient, and being able to create efficient algorithms is one of the factors that distinguishes a good computer scientist. For example, imagine receiving the following set of directions to your friend&acirc;s house instead of the ones shown in the previous section, illustrated on the map in :</p>

<ol>
	<li>
	<p>Start going south on River Road.</p>
	</li>
	<li>
	<p>Turn left (east) one block south of Main Street onto Algorithm Circle.</p>
	</li>
	<li>
	<p>Continue until you come to 345 Algorithm Circle (your friend&acirc;s house).</p>
	</li>
</ol>

<figure id="directions_quotation_markalgorit-id00001" style="float: 0"><img src="images/cspr_0103.png" />
<figcaption>Directions &acirc;efficient algorithm&acirc;</figcaption>
</figure>

<p>Here we use a different algorithm that accomplishes the same task, and it does so slightly more efficiently. That is, fewer turns are involved.</p>
</section>
</section>

<section data-type="sect1" id="onedot4_summary">
<h1>1.4 Summary</h1>

<p>You now understand the core foundations of computer science, namely the use of algorithms to solve real-world problems. Ruby, as used throughout the remainder of the book, is a powerful, yet relatively easy to understand, programming language that can be used to implement these algorithms. It is, however, critical to remember that independent of the programming language used, without a good algorithm, your solution will be ineffective.</p>

<section data-type="sect2" id="onedot4dot1_key_concepts">
<h2>1.4.1 Key Concepts</h2>

<ul>
	<li>
	<p>The essence of computer science is problem solving. Computer science involves using the computer as a tool to model or solve various problems, from storing names in a database to finding efficient directions to a friend&acirc;s house.</p>
	</li>
	<li>
	<p>When programming, it is important to understand that the computer is never wrong. It is merely following the directions you have given it.</p>
	</li>
	<li>
	<p>The following are basic steps for solving a computer science problem:</p>

	<ul class="simplelist">
		<li>Step 1: Understand the problem.</li>
		<li>Step 2: Write out a solution in plain language.</li>
		<li>Step 3: Translate the language into code.</li>
		<li>Step 4: Test the code in the computer.</li>
	</ul>
	</li>
	<li>
	<p>Algorithms are step-by-step methods for solving problems. When writing an algorithm, it is important to keep in mind the algorithm&acirc;s efficiency.</p>
	</li>
</ul>

<div data-type="note" id="ch01note02">
<h1>Gem of Wisdom</h1>

<p>Once we have an algorithm, we can compare it to other algorithms and pick the best one for the job. Once the algorithm is done, we can write a program to implement it.</p>
</div>
</section>

<section data-type="sect2" id="onedot4dot2_key_definitions">
<h2>1.4.2 Key Definitions</h2>

<ul>
	<li>
	<p><em>Algorithm:</em> A step-by-step method for solving problems.</p>
	</li>
	<li>
	<p><em>Algorithm efficiency:</em> A measurement that determines how efficient one algorithm is compared with another.</p>
	</li>
</ul>
</section>
</section>

<section data-type="sect1" id="onedot5_exercises">
<h1>1.5 Exercises</h1>

<ol class="qonly">
	<li>
	<p>Imagine that you are creating a pocket calculator. You have created the functionality for all the buttons except <em>x</em><sup>2</sup>, the button that squares a number, and <em>exp</em>, which allows you to calculate base<sup>exponent</sup>, where <em>exponent</em> is an integer. You may use any other functionality a calculator would normally have: for example, (+, -, *, /, =).</p>

	<ol type="a">
		<li>
		<p>Create the functionality for the <em>x</em><sup>2</sup> button.</p>
		</li>
		<li>
		<p>Create the functionality for the <em>exp</em> button.</p>
		</li>
	</ol>
	</li>
	<li>
	<p>In the third-grade math class of French mathematician Carl Gauss, the teacher needed to give the students some busywork. She asked the class to compute the sum of the first 100 numbers (1 to 100). Long before the rest of the class had finished. Carl raised his hand and told his teacher that he had the answer: 5,050.</p>

	<ol type="a">
		<li>
		<p>Craft an algorithm that will sum the first <em>n</em> numbers (assuming <em>n</em> &acirc;&yen; 1). How many steps does your algorithm take to complete when <em>n</em> = 100? How many steps does it take when <em>n</em> = 1,000?</p>
		</li>
		<li>
		<p>Can you create an algorithm like Gauss&acirc;s where the number of steps does not depend on <em>n</em>?</p>
		</li>
	</ol>
	</li>
	<li>
	<p>A palindrome is a word or phrase that reads the same way forward and backward, like &acirc;racecar.&acirc; Describe a sequence of steps that determines if a word or phrase is a palindrome.</p>
	</li>
	<li>
	<p>Consider the three mazes shown in . Describe two different algorithms for solving a maze. Discuss advantages and disadvantages of each algorithm. Then look at the maze and predict which algorithm will complete first. See if your predictions were correct by applying your algorithms to the mazes.</p>

	<figure id="three_mazes_em_dash_problem_1dot6" style="float: 0"><img src="images/cspr_0106.png" />
	<figcaption>Three mazes for Exercise 4</figcaption>
	</figure>
	</li>
	<li>
	<p>shows an alternative way to represent an algorithm. (Note: we introduce this construct in detail later on. If it looks too intimidating, skip it until after you&acirc;ve read .)</p>

	<ol type="a">
		<li>
		<p>Starting at the circle labeled &acirc;Start&acirc; work your way through the figure. What is the purpose of this algorithm?</p>
		</li>
		<li>
		<p>Translate the figure into simple language. Note that a diamond in the figure represents a condition that may be true or false.</p>
		</li>
	</ol>

	<figure id="algorithm_alternative_em_dash_problem_1d" style="float: 0"><img src="images/cspr_0104.png" />
	<figcaption>Alternative representation of an algorithm for Exercise 5</figcaption>
	</figure>
	</li>
	<li>
	<p>A cable company must use cables to connect 15 homes together so that every home is reachable by every other home. The company has estimated the costs of different cable routes ( shows the numbers associated with each link). One engineer provides an algorithm, shown in , that will find the cheapest set of routes to pick. Does the engineer&acirc;s algorithm work for this case? Why or why not?</p>

	<figure id="cable_company_dilemma_em_dash_problem_1d" style="float: 0"><img src="images/cspr_0105.png" />
	<figcaption>Cable company dilemma for Exercise 6</figcaption>
	</figure>

	<p><strong>Engineer&acirc;s Algorithm:</strong></p>

	<ol>
		<li>
		<p>Pick one cable route with the lowest cost not already picked. Add this route to the set of cheapest routes.</p>
		</li>
		<li>
		<p>Check if every house is connected to every other house through any series of cables. If it isn&acirc;t, go back to step 1. If every house is connected, then the cheapest set of routes has been found.</p>
		</li>
	</ol>
	</li>
</ol>
</section>
</section>
