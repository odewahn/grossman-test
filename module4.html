<section data-type="chapter">
<h1>Module 4 - Defining and Using Playing Cards</h1>

<p>Since blackjack is a game with playing cards, you now have to tell the Ruby interpreter what it needs to know about them. &nbsp;</p>

<p>To do this you first have to define an object called CARD.&nbsp; This CARD object is a thing that the rest of your blackjack program can use.&nbsp;&nbsp; An object can contain data and methods.&nbsp; Data are just a group of variables related to that object and methods are things that the object can do. &nbsp;</p>

<p>The data for a playing card is:</p>

<ul>
	<li>name
	<ul>
		<li>name of the card as in Ace, Jack, Queen, King, 10, 9, 8, &hellip; 1</li>
	</ul>
	</li>
	<li>suit
	<ul>
		<li>either hearts, clubs, spades or diamonds</li>
	</ul>
	</li>
</ul>

<p>So when we crate a new card it will have a home for these two variables.&nbsp; These will be the <strong>data </strong>associated with each card.&nbsp;</p>

<h1>DEFINE AN OBJECT</h1>

<p>&nbsp;</p>

<p>The following Ruby code defines the <strong>Card</strong> object.&nbsp; Think of the <strong>object</strong> like a design of a playing card and an <strong>instance </strong>as an actual playing card.&nbsp; The object simply says playing cards have a suit and a value and an indicator as to whether or not the card has been played.&nbsp; The actual instance is an actual playing card.&nbsp;&nbsp; The code below in line 1 has the special keyword <strong>class</strong> which tells ruby we are defining an object named <strong>Card.&nbsp;&nbsp; </strong>The special name <strong>attr_accessor </strong>is short for <em>attribute accessor </em>as <em>attribute</em> is another name for a variable associated with an object.&nbsp;&nbsp;&nbsp; Line 2 says you can view the values of the data in&nbsp;the variable <strong>name, </strong><strong>suit, </strong>and <strong>value</strong> once you create an <strong>instance</strong> of this object.&nbsp;</p>

<h1>ASSOCIATE DATA WITH THE OBJECT</h1>

<p>&nbsp;</p>

<pre data-type="programlisting">
class Card
&nbsp;&nbsp;&nbsp; attr_accessor :name, :suit&nbsp; &nbsp;
end

</pre>

<p>Once you have this code, you can launch the interactive ruby interpreter <strong>irb </strong>and get a feel for the object.&nbsp;</p>

<pre data-type="programlisting">
irb(main):005:0&gt;my_first_card = Card.new
=&gt; #&lt;Card:0x007fe259af
irb(main):006:0&gt; my_first_card.name
=&gt; nil
irb(main):007:0&gt; my_first_card.suit 
=&gt; nil
</pre>

<p>In this example with the Ruby interpreter, line 1 assigns the variable <strong>my_first_card </strong>to be an instance of the <strong>Card </strong>object.&nbsp; The keyword <strong>new </strong>tells the Ruby interpreter to create a new instance of this object.</p>

<p>To display the variable of a particular instance of an object we use the form <strong><em>instance.variable.&nbsp; </em></strong></p>

<p>Next in line 3 the statement <strong>my_first_card.name&nbsp; </strong>says to display the <strong>name </strong>variable of the object associated with <strong>my_first_card.&nbsp;&nbsp; </strong>The ruby interpreter recognizes that <strong>my_first_card </strong>is an instance of the <strong>Card </strong>object and looks up the value of <strong>name </strong>for this instance.&nbsp;&nbsp; In this case it returns <strong>nil </strong>as it has not been assigned.&nbsp; Similarly, line 5 requests <strong>my_first_card.suit </strong>which is also <strong>nil.&nbsp; </strong></p>

<h1>INITIALIZE AN OBJECT</h1>

<p>So the object we just looked at with the statement <strong>x&nbsp; = Card.new </strong>ended up with a card object being assigned to the <strong>x, </strong>but the values of <strong>name </strong>and <strong>suit </strong>were empty (e.g.; <strong>nil)</strong></p>

<h1>Initializing a Playing Card</h1>

<p>&nbsp;</p>

<p>To play blackjack, you need to be able to create a card like the King of Spades.&nbsp; To do this, use the<strong> initialize </strong>method for the object.</p>

<pre data-type="programlisting">
class Card
&nbsp;&nbsp;&nbsp; attr_accessor :name, :suit&nbsp;&nbsp; &nbsp;

&nbsp;&nbsp;&nbsp; def initialize (name, suit)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @name = name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @suit = suit
&nbsp;&nbsp;&nbsp; end
end
</pre>

<p>Line 4 This is our first <strong>method.&nbsp; </strong>A method is a piece of code that can do something to an object.&nbsp;&nbsp; Once you define a method, the rest of your program&nbsp; that wishes to modify an object uses the method to do it.&nbsp; This makes it so if there are any problems with an object, you know they had to have been caused by one of the objects method.&nbsp; This may not sound like a big deal on a project with only 20-30 lines of Ruby code, but once you get to a project with many thousands of lines of code you will be very grateful to be able to know where to focus your efforts when the program does not work.&nbsp; Line four contains <strong>name </strong>and <strong>suit </strong>in parenthesis ().&nbsp;&nbsp; This is so the calling program can indicate the name and suit at the time of initialization.&nbsp; The value for name and the value for suit may be sent to the initialize method.&nbsp; The variables that are sent to a method are called <em>parameters</em> because the in mathematics the exact definition of a&nbsp; <em>parameter&nbsp; </em>in dictionary.com is:</p>

<blockquote>
<p><em><span class="hwc" id="hotword" name="hotword">a</span> <span class="hwc" id="hotword" name="hotword">constant</span> <span class="hwc" id="hotword" name="hotword">or</span> <span class="hwc" id="hotword" name="hotword">variable</span> <span class="hwc" id="hotword" name="hotword">term</span> <span class="hwc" id="hotword" name="hotword">in</span> <span class="hwc" id="hotword" name="hotword">a</span> <span class="hwc" id="hotword" name="hotword">function</span> <span class="hwc" id="hotword" name="hotword">that</span> <span class="hwc" id="hotword" name="hotword">determines</span> <span class="hwc" id="hotword" name="hotword">the</span> <span class="hwc" id="hotword" name="hotword">specific</span> <span class="hwc" id="hotword" name="hotword">form</span> <span class="hwc" id="hotword" name="hotword">of</span> <span class="hwc" id="hotword" name="hotword">the</span> <span class="hwc" id="hotword" name="hotword">function</span> <span class="hwc" id="hotword" name="hotword">but</span> <span class="hwc" id="hotword" name="hotword">not</span> <span class="hwc" id="hotword" name="hotword">its</span> <span class="hwc" id="hotword" name="hotword">general</span> nature</em></p>
</blockquote>

<p>By sending these parameters to the method Card, you are determining the specific form of a playing card (e.g.; King of Hearts, Ten of Diamonds), not the general form of the card (e.g.; has a name like &quot;King&quot; or &quot;Ten&quot; and a suit).&nbsp; So they are called <em>parameters </em>because that is the word that was already invented that precisely describes what these values that are sent to the <strong>new </strong>method are doing.&nbsp;</p>

<p>The <strong>initialize </strong>method defined in line 3 accepts two parameters:&nbsp; <strong>name and suit.&nbsp; </strong>To create a specific playing card try the following Ruby code:</p>

<pre data-type="programlisting">
class Card
&nbsp;&nbsp;&nbsp; attr_accessor :name, :suit, :value&nbsp;&nbsp; &nbsp;

&nbsp;&nbsp;&nbsp; def initialize (name, suit)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @name = name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @suit = suit
&nbsp;&nbsp;&nbsp; end
end

king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;)
puts &quot;King of Spades ==&gt; &quot; + king_of_spades.name + &quot; &quot; + king_of_spades.suit</pre>

<p>The output you get should be:</p>

<p><strong>King of Spades Name ==&gt; King Suit ==&gt;&nbsp; spades</strong></p>

<p>Essentially in lines 1-8 you define the class for the general nature of a playing card and line 7 <strong>instantiates </strong>(e.g.; create an instance of) a playing card called with a name of King and a Suit of Spades.</p>

<p>At this point we can create any type of playing card we want.&nbsp; If we want to create three different playing cards we would do the following:</p>

<p>Try the following:</p>

<pre data-type="programlisting">
king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;)
queen_of_hearts = Card.new(&quot;Queen&quot;, &quot;hearts&quot;)
jack_of_diamonds = Card.new(&quot;Jack&quot;, &quot;diamonds&quot;)
</pre>

<p>At least now you know how to create a single playing card and you know a little about what an object is and you know how to use the <strong>class </strong>keyword, the <strong>initialize </strong>keyword and what it means to send parameters to a method.&nbsp;&nbsp; At this point we need to talk about a DECK of playing cards.&nbsp; Once we do that we talk about how to DEAL a playing card and then we are mostly done with the game.&nbsp;</p>

<p>Before we do all that, lets talk about some common mistakes before we move on.&nbsp;</p>

<h1>Common Mistake:&nbsp; Wrong number of parameters</h1>

<p>So we have defined an initialize method that takes two parameters and the Ruby interpreter was happy when we sent it &quot;King&quot; for name and &quot;spades&quot; for suit.</p>

<p>Try sending three parameters as in:</p>

<pre data-type="programlisting">
king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;, &quot;extra parameter&quot;)
</pre>

<p>You should get an error message something like this:</p>

<p><strong>ArgumentError: wrong number of arguments (3 for 2)</strong></p>

<p>Sometimes parameters are called <strong>arguments </strong>and so the Ruby interpreter is telling you that you have sent the &quot;wrong number of arguments&quot; and it even tells you it was expecting three and you sent 2 (e.g.; <strong>3 for 2)</strong></p>

<h1>Common Mistake: Missing END statement at the end of a class</h1>

<p>It is very easy to forget the END statement at the end of class.&nbsp; Your code would now look like:&nbsp;</p>

<p>&nbsp;</p>

<pre data-type="programlisting">
class Card
&nbsp;&nbsp;&nbsp; attr_accessor :name, :suit, :value&nbsp;&nbsp; &nbsp;

&nbsp;&nbsp;&nbsp; def initialize (name, suit)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @name = name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @suit = suit
&nbsp;&nbsp;&nbsp; end

king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;)
puts &quot;King of Spades Name ==&gt; &quot; + king_of_spades.name + &quot; Suit ==&gt;&nbsp; &quot; + king_of_spades.suit</pre>

<p>Notice after line 7 we have a nice <strong>end </strong>to match up with our definition of the <strong>initialize </strong>method, but we have no additional <strong>end </strong>to end our class definition.</p>

<p>We now get the&nbsp; error:</p>

<p><strong>syntax error, unexpected end-of-input, expecting keyword_end</strong></p>

<p>The Ruby interpreter tells us that it was expecting a keyword end, but it's not clear where to put the missing end.&nbsp; Usually the interpreter gives you a line number to start looking and that can be helpful.&nbsp;&nbsp; This can be a tough error to fix when you have thousands of lines of code and shows why it's a really good practice to include plenty of whitespace in your code.&nbsp; Hit enter at the end of blocks to add vertical space and <strong>INDENT </strong>when you are writing code inside of a block.&nbsp; Imagine if your code above looked like:</p>

<pre class="pre " data-type="programlisting">
class Card
attr_accessor :name, :suit, :value&nbsp;&nbsp; 
def initialize (name, suit)
@name = name
@suit = suit
end
king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;)
puts &quot;King of Spades Name ==&gt; &quot; + king_of_spades.name + &quot; Suit ==&gt;&nbsp; &quot; + king_of_spades.suit
</pre>

<p>New programmers often write code this way because they are struggling to get the hang of everything and they think indenting and adding more whitespace just adds to the time it takes to type things in.&nbsp; Professional programmers always beautifully indent their code because they know what its like to try to find things like a missing <strong>end. </strong></p>

<p>&nbsp;</p>

<h1>Common Mistake: Leaving out a Parethensis</h1>

<p>Another common mistake is to not close your parenthesis.&nbsp; Try this:</p>

<pre data-type="programlisting">
class Card
&nbsp;&nbsp;&nbsp; attr_accessor :name, :suit, :value&nbsp;&nbsp; &nbsp;

&nbsp;&nbsp;&nbsp; def initialize (name, suit)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @name = name
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @suit = suit
&nbsp;&nbsp;&nbsp; end
end

king_of_spades = Card.new(&quot;King&quot;, &quot;spades&quot;
puts &quot;King of Spades Name ==&gt; &quot; + king_of_spades.name + &quot; Suit ==&gt;&nbsp; &quot; + king_of_spades.suit</pre>

<p>Line 9 calls the <strong>initialize </strong>method with the <strong>new </strong>keyword and sends two arguments along, but does not include the closing parenthesis.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>
</section>
